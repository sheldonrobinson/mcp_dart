import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:build/build.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';

class MasonBundleBuilder implements Builder {
  @override
  final buildExtensions = const {
    'brick.yaml': ['brick.bundle.dart'],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final inputId = buildStep.inputId;

    // Calculate the directory of the brick from the input file
    final packagePath = p.absolute('.');
    final brickDir = p.dirname(p.join(packagePath, inputId.path));
    final brickYamlPath = p.join(brickDir, 'brick.yaml');
    final brickTemplateDir = p.join(brickDir, '__brick__');

    log.info('Bundling brick at $brickDir');

    // Read brick.yaml to get metadata
    final brickYamlFile = File(brickYamlPath);
    final brickYamlContent = await brickYamlFile.readAsString();
    final brickYaml = loadYaml(brickYamlContent) as YamlMap;

    // Read .tpl files from __brick__ directory and construct bundle manually
    // This avoids pana trying to analyze .dart files with template variables
    final templateFiles = <Map<String, dynamic>>[];
    final templateDir = Directory(brickTemplateDir);

    if (await templateDir.exists()) {
      await for (final entity in templateDir.list(recursive: true)) {
        if (entity is File && entity.path.endsWith('.tpl')) {
          final relativePath = p.relative(entity.path, from: brickTemplateDir);
          // Remove .tpl extension to get the target filename
          final targetPath = relativePath.substring(0, relativePath.length - 4);
          final content = await entity.readAsString();
          final base64Content = base64Encode(utf8.encode(content));
          templateFiles.add({
            'path': targetPath,
            'data': base64Content,
            'type': 'text',
          });
        }
      }
    }

    // Build bundle JSON manually
    final bundleJson = <String, dynamic>{
      'files': templateFiles,
      'hooks': <dynamic>[],
      'name': brickYaml['name'] as String,
      'description': brickYaml['description'] as String? ?? '',
      'version': brickYaml['version'] as String? ?? '0.1.0',
      'environment': {
        'mason': (brickYaml['environment'] as YamlMap?)?['mason'] as String? ??
            '>=0.1.0-dev.1 <0.1.0',
      },
      'vars': _convertVars(brickYaml['vars'] as YamlMap?),
    };

    final outputId = inputId.changeExtension('.bundle.dart');
    // Convert snake_case or whatever to camelCase + Bundle
    final bundleName = bundleJson['name'] as String;
    final varName = '${_toCamelCase(bundleName)}Bundle';

    final content = '''
// Generated by MasonBundleBuilder
import 'package:mason/mason.dart';

final $varName = MasonBundle.fromJson(${_jsonToDart(bundleJson)});
''';

    await buildStep.writeAsString(outputId, content);
  }

  String _toCamelCase(String input) {
    if (!input.contains('_')) return input;
    return input
        .split('_')
        .asMap()
        .map((i, w) {
          if (i == 0) return MapEntry(i, w);
          if (w.isEmpty) return MapEntry(i, w);
          return MapEntry(i, w[0].toUpperCase() + w.substring(1));
        })
        .values
        .join('');
  }

  Map<String, dynamic> _convertVars(YamlMap? vars) {
    if (vars == null) return {};
    final result = <String, dynamic>{};
    for (final entry in vars.entries) {
      final key = entry.key as String;
      final value = entry.value;
      if (value is YamlMap) {
        result[key] = <String, dynamic>{
          'type': value['type'] as String? ?? 'string',
          'description': value['description'] as String? ?? '',
        };
      } else {
        result[key] = {'type': 'string', 'description': ''};
      }
    }
    return result;
  }

  String _jsonToDart(Map<String, dynamic> json) {
    final buffer = StringBuffer();
    _writeMap(buffer, json);
    return buffer.toString();
  }

  void _writeMap(StringBuffer buffer, Map<String, dynamic> map) {
    buffer.write('{');
    map.forEach((key, value) {
      buffer.write("'$key': ");
      _writeValue(buffer, value);
      buffer.write(', ');
    });
    buffer.write('}');
  }

  void _writeValue(StringBuffer buffer, dynamic value) {
    if (value is String) {
      if (value.contains('\n')) {
        buffer.write("'''${value.replaceAll("'''", "\\'''")}'''");
      } else {
        buffer.write("'${value.replaceAll("'", "\\'")}'");
      }
    } else if (value is num || value is bool || value == null) {
      buffer.write(value);
    } else if (value is List) {
      buffer.write('[');
      for (var item in value) {
        _writeValue(buffer, item);
        buffer.write(', ');
      }
      buffer.write(']');
    } else if (value is Map) {
      _writeMap(buffer, value as Map<String, dynamic>);
    }
  }
}

Builder masonBundleBuilder(BuilderOptions options) => MasonBundleBuilder();
